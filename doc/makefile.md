


## 这是一个关于ZerOS-0.0.1 的 makefile 系统的文档

#### 本OS有参考xv6的实现，作为一个教学用的操作系统，xv6仍然不可避免地存在一些不足，比如xv6的源码*.c,*.o都存放在同一个文件夹之下，导致结构比较混乱，所以我们采用了源代码和目标文件分离的模式

工程文件将被分目录存放：

```
.
├── bootloader  SBI相关
├── build       编译输出
├── changelog   项目变更日志
├── doc         项目详细文档
├── entry       系统调用表与性能分析表
├── include     头文件目录
├── Makefile    构建文件
├── README
├── run-gdb.sh  
├── run-qemu.sh
├── script      编译用脚本
├── src         源文件目录
├── test        测试调试目录，包含测试日志
├── tools       常用工具
├── user        用户程序目录
└── 操作系统内核设计赛文档.pdf
```


#### 同时，我们的Makefile被编写为递归目录构建，这意味着在ZerOS中存在多个子目录，每个子目录都有自己的 Makefile 文件，并且这些子目录中的 Makefile 文件可以相互调用和执行，形成一种层级结构。

关于递归调用makefile构建：

递归目录构建的主要思想是在主 Makefile 文件中调用每个子目录的 Makefile 文件，从而实现整个项目的构建过程。主 Makefile 文件会按照一定的顺序递归地进入每个子目录，执行相应的构建操作。这样可以实现多个子目录的并行构建，提高构建效率。

递归目录构建通常使用 make -C 命令来调用子目录的 Makefile 文件。例如，make -C subdir 表示进入名为 subdir 的子目录，并执行该子目录下的 Makefile 文件。

通过递归目录构建，可以更好地管理和组织复杂的项目结构，提高代码的可维护性和可扩展性。同时，它也允许不同模块之间的并行构建，加快整体构建过程。


#### 每个文件夹下的Makefile将只会编译当前的文件夹下的源文件，同时将目标.o文件输出到与/ZerOS/src拥有相同目录结构的//build/objs目录下，这样做的目的在于结构化输出文件，与源文件形成一一对应的关系，便于查看以及维护。

递归构建遵循子目录优先构建的原则，也就是说，子目录将总会被优先编译，此后再编译当前目录下的源文件。

回忆一下我们原本的项目编译链接的过程：原本我们是将所有的.c文件全部编译为.o对象，然后在对所有的这些.o文件链接最终得到我们想要的文件。但是实际上大型项目往往文件层次结构比较复杂，并不是所有的文件全部在一个文件夹之下，往往是树状结构，这样我们便可以考虑一种从顶向下进入，再从低向上逐层编译连接的过程。

这实际上的实现是基于我们ld 的-r选项（partial linking）实现的，实际上我们可以先编译得到当前目录地的所有.o文件，然后将这些.o文件和所有部分链接得到的子目录下一对一的.o文件链接得到一个唯一的.o文件，我们的名字叫做built-in.o文件。


以上对构建过程进行了简单的阐述，更加详细的内容可以参考script/Makefile.build，src/kernel/Makefile。

#### 杂项

内核的平台相关代码将基于给定的platform参数来决定编译目录，从而避免了源代码内出现大量IFDEFINE QEMU的宏判断语句，但是出于以后一些特殊的需要，构建参数也根据platform加入了-DQEMU或-DK210的编译宏选项。



